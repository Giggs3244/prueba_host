# A continuacion se presenta un archivo variabilizado, que es usado en los ambientes de pruebas y produccion para
# backends en EKS.
# La funcionalidad de los Ampersand "&" permiten determinar el nombre de la variable, la cual debe ser añadida en el
# ambiente de pruebas y
# produccion de urban code, con su valor correspondiente.
# El funcionamiento en urban code es el siguiente: Este archivo (configsecret.yaml) viene en la entrega que envia
# jenkins desde la ejecucion del respectivo pipeline. Urban code lee este archivo e identifica inicialmente a que
# aplicacion, microservicio y ambiente pertenece y de acuerdo a esto sustituye los valores respectivos que se encuentren
# por ambiente.
# Por lo que es importante que en urban code las variables aqui mostradas existan en el ambiente de pruebas y produccion.
# Para mayor entendimiento un ejemplo.
#
# ejemplo: se tiene la siguiente variable identificada en el archivo como &datasource_url&
# Lo que esta dentro los Ampersand "&" representan el nombre de la variable como debe ser añadida en urban code, es
# decir, datasource_url  los valores que esa variable va a tener deben ser definidos en los ambientes de urban code del
# microservico, serian:
# El valor para pruebas: jdbc:postgresql://awsdbqa001.proteccion.com.co:5432/proteccionbdqa?currentSchema=nombre_esquemacxn2
#     (valor que corresponde a la base de datos general de qa y esquema del microservicio en pruebas)
# EL valor para prod: jdbc:postgresql://awsdbprod001.proteccion.com.co/rdsprodpos001?currentSchema=nombre_esquemacxn1
#     (valor de la base de datos general de prod y esquema del microservicio en prod)

# ########################################################################
# Esta plantilla fue elaborada y es manetenida por el equipo de 3HTP.
# ########################################################################

apiVersion: v1
kind: Secret
metadata:
  name: dominio-subdominio-ms #de acuerdo al dominio y subdominio al que pertenece
  namespace: &namespace&
type: Opaque
stringData:
  application.yml: |
    server:
      host: &server_host&
      port: &server_port& #puerto por donde se expone el microservicio, definido desde la construccion de la imagen por el puerto 8443, ya definido en arquitectura de referencia
      compression:
        enabled: &compression_enabled&
        mime-types: &compression_mime-types&
        min-response-size: &compression_min-response-size&
      error:
        includeStacktrace: &error_includeStacktrace&
      mq: #Colas (Sqs) y topicos (sns) de aws, variables definidas con la ejecución del terraform de referencia
        receive-timeout: &mq_receive-timeout&
        publishDestination: &mq_publishDestination& #topico de aplicacion aws (t-dominio-subdominio-microservicio-ambiente)
        subscribeDestination: &mq_subscribeDestination& #cola de aplicacion aws (q-dominio-subdominio-microservicio-ambiente)
        errorDestination: &mq_errorDestination& #topico de error aplicacion aws (t-dominio-subdominio-microservicio-err-ambiente)
        concurrency: &mq_concurrency&
        aws:
          concurrency: &aws_concurrency&

    cloud:
      aws:
        stack:
          auto: &stack_auto&
        region:
          static: &region_static& #region donde se crean los recursos (colas, topicos, suscripciones, buckets). Definida desde arquitectura "us-east-1"
        credentials:          #credenciales de usuario Iam de aws del microservicio con permisos sobres colas, topicos, buckets (definido en terraform de referencia)
          instanceProfile: &credentials_instanceProfile&
          use-default-aws-credentials-chain: true
          # accessKey: &credentials_accessKey& #identifica el usuario IAM que se crea en la consola de aws con el terraform de referencia
          # secretKey: &credentials_secretKey& #necesario para la extracción de mensajes de los mensajes o publicación de mensajes

    spring: #Datos de conexión a base de datos
      datasource:
        url: &datasource_url& #variable que corresponde a la base de datos general del ambiente, se incluye esquema al que se va a conectar
        username: &datasource_username& #usuario de de conexión, con permisos sobre el esquema al que se quiere conectar
        password: &datasource_password& #password del usuario de conexión al esquema especificado en &datasource_url&
        driver-class-name: &datasource_driver-class-name&

    logging:
      level:
        root: &datasource_logging.level.root&
        co.com.proteccion: &datasource_logging.level.co.com.proteccion&
        org.springframework.http.codec.json: &datasource_logging.level.org.springframework.http.codec.json&
    securedApplication:
      name: &securedApplication_name&
      idAppProteccion: &securedApplication_idAppProteccion&
      corsAllowOrigin: &securedApplication_corsAllowOrigin&
      corsAllowHeader: &corsAllowHeader&
      corsExposeHeader: &corsExposeHeader&
      validateTokenIP: &securedApplication_validateTokenIP&
      busBaseUrl: &busBaseUrl& #variable correspondiente a los servicios de integración,
      useJsonRepository: &securedApplication_useJsonRepository&
      janoEnabled: &securedApplication_janoEnabled&
      azure:      #De acuerdo a donde perteneza, empresas o afiliados
        scopeEmpresas:
          clientId: &scopeEmpresas_clientId&
          tenant: &scopeEmpresas_tenant&
          clientSecret: &scopeEmpresas_clientSecret&
          profile: &scopeEmpresas_profile&

    app.env: &aws_app.env& #identificacion del microservicio y ambiente, aqui ya empiezan las variables independientes que maneja cada microservicio